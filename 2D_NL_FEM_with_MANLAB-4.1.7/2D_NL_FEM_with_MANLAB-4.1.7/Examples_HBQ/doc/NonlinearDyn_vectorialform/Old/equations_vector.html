<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of equations_vector</title>
  <meta name="keywords" content="equations_vector">
  <meta name="description" content="Equations of the system of the form">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">NonlinearDyn_vectorialform</a> &gt; <a href="index.html">Old</a> &gt; equations_vector.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for NonlinearDyn_vectorialform\Old&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>equations_vector
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Equations of the system of the form</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [Rf,dRa,Forcing] = equations_vector(sys, t, zf, dzf, d2zf) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Equations of the system of the form 
 Rf(zf) = C + L0(zf) + lambda L1(zf) + D0(dzf) + lambda D1(dzf) + DD(d2zf) + Q(zf,zf) + f(zf).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="global_to_active.html" class="code" title="function idof = global_to_active(iglob, active)">global_to_active</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Rf,dRa,Forcing] = equations_vector(sys, t, zf, dzf, d2zf)</a>
0002 <span class="comment">% Equations of the system of the form</span>
0003 <span class="comment">% Rf(zf) = C + L0(zf) + lambda L1(zf) + D0(dzf) + lambda D1(dzf) + DD(d2zf) + Q(zf,zf) + f(zf).</span>
0004 
0005 sizing = size(zf,2);
0006 
0007 <span class="comment">%keyboard</span>
0008 R     = zeros(sys.nz,sizing);      <span class="comment">% Main residue</span>
0009 Ra    = zeros(sys.nz_aux,sizing);  <span class="comment">% Auxiliary residue</span>
0010 dRa   = zeros(sys.nz_aux,sizing);  <span class="comment">% Differential form of non-quadratic part of the auxiliary residue</span>
0011 
0012 <span class="comment">%%% parameters of the system</span>
0013 number_nodes = sys.parameters.mesh.number_nodes;
0014 number_elements = sys.parameters.mesh.number_elements;
0015 n_var = sys.nz/2; <span class="comment">% location of first variable u</span>
0016 
0017 <span class="comment">%index = sys.parameters.element_geometry.element_index;</span>
0018 active_dof = sys.parameters.dof_info.active;
0019 prescribed_dof = sys.parameters.dof_info.bc.prescribed_dof;
0020 
0021 E = sys.parameters.beam_params.modulus;
0022 A = sys.parameters.beam_params.area;
0023 I = sys.parameters.beam_params.I;
0024 G = sys.parameters.beam_params.shear;
0025 k = sys.parameters.beam_params.k; <span class="comment">% shear coefficient</span>
0026 rho = sys.parameters.beam_params.density;
0027 <span class="comment">%% Variables :</span>
0028 u      = zf(1:n_var,:);           du     = dzf(1:n_var,:);             <span class="comment">% Main variable: u = position</span>
0029 v      = zf(n_var + 1:2*n_var,:); dv     = dzf(n_var + 1:2*n_var,:);   <span class="comment">% Main variable: v = velocity</span>
0030 aux    = zf(2*n_var + 1:end-1,:); daux   = dzf(2*n_var + 1:<span class="keyword">end</span>,:);     <span class="comment">% Auxiliary variables</span>
0031 lambda = zf(<span class="keyword">end</span>,:);                                                  <span class="comment">% Continuation parameter</span>
0032 
0033 <span class="comment">% decomposition of aux:</span>
0034 up     = aux(              1:   number_elements,:);
0035 wp     = aux(   number_elements + 1: 2*number_elements,:);
0036 thetap = aux( 2*number_elements + 1: 3*number_elements,:);
0037 theta  = aux( 3*number_elements + 1: 4*number_elements,:);  dtheta = daux(3*number_elements + 1:4*number_elements,:);
0038 c      = aux( 4*number_elements + 1: 5*number_elements,:);      dc = daux(4*number_elements + 1:5*number_elements,:);
0039 s      = aux( 5*number_elements + 1: 6*number_elements,:);      ds = daux(5*number_elements + 1:6*number_elements,:);
0040 eps    = aux( 6*number_elements + 1: 7*number_elements,:);
0041 gam    = aux( 7*number_elements + 1: 8*number_elements,:);
0042 Fx     = aux( 8*number_elements + 1: 9*number_elements,:);
0043 Fy     = aux( 9*number_elements + 1:10*number_elements,:);
0044 M      = aux(10*number_elements + 1:11*number_elements,:);
0045 T2     = aux(11*number_elements + 1:12*number_elements,:);
0046 
0047 <span class="comment">% constructing q from Main variable u:</span>
0048 q_global = zeros(3*number_nodes,sizing);
0049 q_global(prescribed_dof,:) = 0; <span class="comment">%%%% generalize (see Cochelin line 59)</span>
0050 q_global(active_dof,:) = u;
0051 
0052 f_int_global = zeros(3*number_nodes,sizing);
0053 M_global =  sys.parameters.M_glob;
0054 f_ext_global = sys.parameters.f_ext_glob;
0055 
0056 <span class="keyword">for</span> i = 1:number_elements
0057     nodeA = sys.parameters.mesh.connect(i,2);
0058     nodeB = sys.parameters.mesh.connect(i,3);
0059     
0060     index_global_A = 3*(nodeA - 1) + (1:3);
0061     index_global_B = 3*(nodeB - 1) + (1:3);
0062     
0063     index = [index_global_A index_global_B]';
0064     
0065     [L_element(i), theta_element(i)] = elementOrientation(sys.parameters.mesh,i);
0066     rot_matrix = transformationMatrix(theta_element(i));
0067     q_element = rot_matrix'*q_global(index,:); <span class="comment">% rotating q_element into local frame</span>
0068     
0069     f_int_elem = [-Fx(i,:);
0070         -Fy(i,:);
0071         -M(i,:) + T2(i,:)*L_element(i)/2; 
0072         Fx(i,:);
0073         Fy(i,:);
0074         M(i,:) + T2(i,:)*L_element(i)/2];
0075     f_int_global(index,:) = f_int_global(index,:) + rot_matrix*f_int_elem;
0076     
0077 <span class="comment">%     if strcmp(parameters.loads.type, 'Distributed force')</span>
0078 <span class="comment">%         f_ext_elem = [0; L_element(i)/2; 0; 0; L_element(i); 0];</span>
0079 <span class="comment">%         f_ext_global(index,:) = f_ext_global(index,:) + rot_matrix*f_ext_elem; % distributed external force</span>
0080 <span class="comment">%     end</span>
0081 
0082     Ra(i,:)                 = up(i,:)     - ((q_element(4,:) - q_element(1,:))/L_element(i));   
0083     Ra(i +   number_elements,:) = wp(i,:)     - ((q_element(5,:) - q_element(2,:))/L_element(i));
0084     Ra(i + 2*number_elements,:) = thetap(i,:) - ((q_element(6,:) - q_element(3,:))/L_element(i));
0085     Ra(i + 3*number_elements,:) = theta(i,:)  - ((q_element(6,:) + q_element(3,:))/2);
0086     
0087 <span class="keyword">end</span>
0088 N = E*A.*eps;
0089 T = k*G*A.*gam;
0090 
0091 <span class="comment">% Remaining auxiliary variable residuals</span>
0092 Ra( 4*number_elements + 1: 5*number_elements,:)  = c - cos(theta);                 dRa(4*number_elements + 1: 5*number_elements,:) = dc + s.*dtheta;
0093 Ra( 5*number_elements + 1: 6*number_elements,:)  = s - sin(theta);                 dRa(5*number_elements + 1: 6*number_elements,:) = ds - c.*dtheta;
0094 Ra( 6*number_elements + 1: 7*number_elements,:)  = eps - (1 + up).*c - wp.*s + 1;
0095 Ra( 7*number_elements + 1: 8*number_elements,:)  = gam - wp.*c + (1 + up).*s;
0096 
0097 Ra( 8*number_elements + 1: 9*number_elements,:)  = Fx - N.*c + T.*s;
0098 Ra( 9*number_elements + 1: 10*number_elements,:) = Fy - N.*s - T.*c;
0099 Ra(10*number_elements + 1: 11*number_elements,:) = M - E*I*thetap;
0100 Ra(11*number_elements + 1: 12*number_elements,:) = T2 - N.*gam + (1 + eps).*T;
0101 
0102 C_global = sys.parameters.C_glob;
0103 
0104 v_global = zeros(3*number_nodes,sizing); <span class="comment">% needed to calculate the residual</span>
0105 v_global(active_dof,:) = v;
0106 
0107 dv_global = zeros(3*number_nodes,sizing); <span class="comment">% needed to calculate the residual</span>
0108 dv_global(active_dof,:) = dv;
0109 
0110 Residual = -f_int_global - M_global*dv_global - C_global*v_global;
0111 <span class="comment">%% Residues</span>
0112 <span class="comment">% Equations of the main system</span>
0113 R(1:n_var,:) = v - du;
0114 R(n_var + 1:2*n_var,:) = Residual(active_dof,:);
0115 
0116 <span class="comment">% Concatenation of the two residues</span>
0117 Rf = [ R ; Ra ];
0118 
0119 <span class="comment">%% Forcing terms</span>
0120 <span class="comment">% Should be written as if the forcing angular frequency value is 1</span>
0121 <span class="comment">% i.e. the forcing period is 2*pi</span>
0122 Forcing = zeros(2*sys.H+1,sys.nz_tot); <span class="comment">% DO NOT CHANGE this line.</span>
0123 loads = sys.parameters.loads;
0124 dof_loc = <a href="global_to_active.html" class="code" title="function idof = global_to_active(iglob, active)">global_to_active</a>(loads.dof, active_dof);
0125 <span class="keyword">if</span> strcmp(loads.type, <span class="string">'Point force'</span>) <span class="comment">% point force at specific nodes</span>
0126     Forcing(:,(dof_loc + n_var)) = loads.amplitude_cos*cos(t) + loads.amplitude_sin*sin(t);
0127 <span class="keyword">elseif</span> strcmp(loads.type, <span class="string">'Distributed force'</span>) <span class="comment">% distributed force due to imposed acceleration</span>
0128 <span class="comment">%     Forcing(:,(dof_loc + n_var)) = rho * A * repmat(f_ext_global',size(Forcing(:,(dof_loc + n_var)),1),1) * (loads.amplitude_cos*cos(t) + loads.amplitude_sin*sin(t));</span>
0129     <span class="keyword">for</span> i = 1:length(dof_loc)
0130         Forcing(:,(dof_loc(i) + n_var)) = rho * A * f_ext_global(i) * (loads.amplitude_cos*cos(t) + loads.amplitude_sin*sin(t));
0131     <span class="keyword">end</span>
0132 <span class="keyword">end</span>
0133 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 17-Oct-2022 20:14:50 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>