<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of equations_linear_vector</title>
  <meta name="keywords" content="equations_linear_vector">
  <meta name="description" content="Equations of the system of the form">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">NonlinearDyn_vectorialform</a> &gt; <a href="index.html">Old</a> &gt; equations_linear_vector.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for NonlinearDyn_vectorialform\Old&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>equations_linear_vector
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Equations of the system of the form</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [Rf,dRa,Forcing] = equations_linear_vector(sys, t, zf, dzf, d2zf) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Equations of the system of the form 
 Rf(zf) = C + L0(zf) + lambda L1(zf) + D0(dzf) + lambda D1(dzf) + DD(d2zf) + Q(zf,zf) + f(zf).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="global_to_active.html" class="code" title="function idof = global_to_active(iglob, active)">global_to_active</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Rf,dRa,Forcing] = equations_linear_vector(sys, t, zf, dzf, d2zf)</a>
0002 <span class="comment">% Equations of the system of the form</span>
0003 <span class="comment">% Rf(zf) = C + L0(zf) + lambda L1(zf) + D0(dzf) + lambda D1(dzf) + DD(d2zf) + Q(zf,zf) + f(zf).</span>
0004 
0005 sizing = size(zf,2);
0006 
0007 <span class="comment">%keyboard</span>
0008 R     = zeros(sys.nz,sizing);      <span class="comment">% Main residue</span>
0009 Ra    = zeros(sys.nz_aux,sizing);  <span class="comment">% Auxiliary residue</span>
0010 dRa   = zeros(sys.nz_aux,sizing);  <span class="comment">% Differential form of non-quadratic part of the auxiliary residue</span>
0011 
0012 <span class="comment">%%% parameters of the system</span>
0013 number_nodes = sys.parameters.mesh.number_nodes;
0014 number_elements = sys.parameters.mesh.number_elements;
0015 n_var = sys.nz/2; <span class="comment">% location of first variable u</span>
0016 
0017 <span class="comment">%index = sys.parameters.element_geometry.element_index;</span>
0018 active_dof = sys.parameters.dof_info.active;
0019 prescribed_dof = sys.parameters.dof_info.bc.prescribed_dof;
0020 
0021 E = sys.parameters.beam_params.modulus;
0022 A = sys.parameters.beam_params.area;
0023 I = sys.parameters.beam_params.I;
0024 G = sys.parameters.beam_params.shear;
0025 k = sys.parameters.beam_params.k; <span class="comment">% shear coefficient</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% L_element = sys.parameters.element_geometry.L_element;</span>
0028 <span class="comment">% theta_element = sys.parameters.element_geometry.theta_element;</span>
0029 
0030 <span class="comment">%% Variables :</span>
0031 u      = zf(1:n_var,:);           du     = dzf(1:n_var,:);             <span class="comment">% Main variable: u = position</span>
0032 v      = zf(n_var + 1:2*n_var,:); dv     = dzf(n_var + 1:2*n_var,:);   <span class="comment">% Main variable: v = velocity</span>
0033 aux    = zf(2*n_var + 1:end-1,:); daux   = dzf(2*n_var + 1:<span class="keyword">end</span>,:);     <span class="comment">% Auxiliary variables</span>
0034 lambda = zf(<span class="keyword">end</span>,:);                                                  <span class="comment">% Continuation parameter</span>
0035 
0036 <span class="comment">% decomposition of aux:</span>
0037 up     = aux(              1:   number_elements,:);
0038 wp     = aux(   number_elements + 1: 2*number_elements,:);
0039 thetap = aux( 2*number_elements + 1: 3*number_elements,:);
0040 theta  = aux( 3*number_elements + 1: 4*number_elements,:);  
0041 c      = aux( 4*number_elements + 1: 5*number_elements,:);      
0042 s      = aux( 5*number_elements + 1: 6*number_elements,:);      
0043 eps    = aux( 6*number_elements + 1: 7*number_elements,:);
0044 gam    = aux( 7*number_elements + 1: 8*number_elements,:);
0045 Fx     = aux( 8*number_elements + 1: 9*number_elements,:);
0046 Fy     = aux( 9*number_elements + 1:10*number_elements,:);
0047 M      = aux(10*number_elements + 1:11*number_elements,:);
0048 T2     = aux(11*number_elements + 1:12*number_elements,:);
0049 
0050 <span class="comment">% constructing q from Main variable u:</span>
0051 q_global = zeros(3*number_nodes,sizing);
0052 q_global(prescribed_dof,:) = 0; <span class="comment">%%%% generalize (see Cochelin line 59)</span>
0053 q_global(active_dof,:) = u;
0054 
0055 f_int_global = zeros(3*number_nodes,sizing);
0056 M_global =  sys.parameters.M_glob;
0057 
0058 <span class="keyword">for</span> i = 1:number_elements
0059     nodeA = sys.parameters.mesh.connect(i,2);
0060     nodeB = sys.parameters.mesh.connect(i,3);
0061     
0062     index_global_A = 3*(nodeA - 1) + (1:3);
0063     index_global_B = 3*(nodeB - 1) + (1:3);
0064     
0065     index = [index_global_A index_global_B]';
0066     
0067     [L_element(i), theta_element(i)] = elementOrientation(sys.parameters.mesh,i);
0068     rot_matrix = transformationMatrix(theta_element(i));
0069     q_element = rot_matrix'*q_global(index,:); <span class="comment">% rotating q_element into local frame</span>
0070     
0071     f_int_elem = [-Fx(i,:); -Fy(i,:); -M(i,:) + T2(i,:)*L_element(i)/2; Fx(i,:); Fy(i,:); M(i,:) + T2(i,:)*L_element(i)/2];
0072     f_int_global(index,:) = f_int_global(index,:) + rot_matrix*f_int_elem;
0073 
0074     Ra(i,:)                 = up(i,:)     - ((q_element(4,:) - q_element(1,:))/L_element(i));   
0075     Ra(i +   number_elements,:) = wp(i,:)     - ((q_element(5,:) - q_element(2,:))/L_element(i));
0076     Ra(i + 2*number_elements,:) = thetap(i,:) - ((q_element(6,:) - q_element(3,:))/L_element(i));
0077     Ra(i + 3*number_elements,:) = theta(i,:)  - ((q_element(6,:) + q_element(3,:))/2);    
0078     
0079 <span class="keyword">end</span>
0080 N = E*A*eps;
0081 T = k*G*A*gam;
0082 
0083 <span class="comment">% Remaining auxiliary variable residuals</span>
0084 Ra( 4*number_elements + 1: 5*number_elements,:)  = c - 1;                 
0085 Ra( 5*number_elements + 1: 6*number_elements,:)  = s - theta;                 
0086 Ra( 6*number_elements + 1: 7*number_elements,:)  = eps -  up;
0087 Ra( 7*number_elements + 1: 8*number_elements,:)  = gam - wp + s;
0088 Ra( 8*number_elements + 1: 9*number_elements,:)  = Fx - N ;
0089 Ra( 9*number_elements + 1: 10*number_elements,:) = Fy - T;
0090 Ra(10*number_elements + 1: 11*number_elements,:) = M - E*I*thetap;
0091 Ra(11*number_elements + 1: 12*number_elements,:) = T2 - N.*gam + (1+eps).*T;
0092 
0093 C_global = sys.parameters.C_glob;
0094 
0095 v_global = zeros(3*number_nodes,sizing); <span class="comment">% needed to calculate the residual</span>
0096 v_global(active_dof,:) = v;
0097 
0098 dv_global = zeros(3*number_nodes,sizing); <span class="comment">% needed to calculate the residual</span>
0099 dv_global(active_dof,:) = dv;
0100 
0101 Residual = -f_int_global - M_global*dv_global - C_global*v_global;
0102 <span class="comment">%% Residues</span>
0103 <span class="comment">% Equations of the main system</span>
0104 R(1:n_var,:) = v - du;
0105 R(n_var + 1:2*n_var,:) = Residual(active_dof,:);
0106 
0107 <span class="comment">% Concatenation of the two residues</span>
0108 Rf = [ R ; Ra ];
0109 
0110 <span class="comment">%% Forcing terms</span>
0111 <span class="comment">% Should be written as if the forcing angular frequency value is 1</span>
0112 <span class="comment">% i.e. the forcing period is 2*pi</span>
0113 Forcing = zeros(2*sys.H+1,sys.nz_tot); <span class="comment">% DO NOT CHANGE this line.</span>
0114 loads = sys.parameters.loads;
0115 dof_loc = <a href="global_to_active.html" class="code" title="function idof = global_to_active(iglob, active)">global_to_active</a>(loads.dof, active_dof);
0116 Forcing(:,(dof_loc + n_var)) = loads.amplitude_cos*cos(t) + loads.amplitude_sin*sin(t);
0117 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 17-Oct-2022 20:14:50 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>