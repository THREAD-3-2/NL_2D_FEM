<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of equations_vector_nnm</title>
  <meta name="keywords" content="equations_vector_nnm">
  <meta name="description" content="Equations of the system of the form">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">NonlinearDyn_vectorialform</a> &gt; <a href="index.html">Old</a> &gt; equations_vector_nnm.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for NonlinearDyn_vectorialform\Old&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>equations_vector_nnm
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Equations of the system of the form</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [Rf,dRa,Forcing] = equations_vector_nnm(sys, t, zf, dzf, d2zf) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Equations of the system of the form 
 Rf(zf) = C + L0(zf) + lambda L1(zf) + D0(dzf) + lambda D1(dzf) + DD(d2zf) + Q(zf,zf) + f(zf).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Rf,dRa,Forcing] = equations_vector_nnm(sys, t, zf, dzf, d2zf)</a>
0002 <span class="comment">% Equations of the system of the form</span>
0003 <span class="comment">% Rf(zf) = C + L0(zf) + lambda L1(zf) + D0(dzf) + lambda D1(dzf) + DD(d2zf) + Q(zf,zf) + f(zf).</span>
0004 
0005 sizing = size(zf,2);
0006 
0007 <span class="comment">%keyboard</span>
0008 R     = zeros(sys.nz,sizing);      <span class="comment">% Main residue</span>
0009 Ra    = zeros(sys.nz_aux,sizing);  <span class="comment">% Auxiliary residue</span>
0010 dRa   = zeros(sys.nz_aux,sizing);  <span class="comment">% Differential form of non-quadratic part of the auxiliary residue</span>
0011 
0012 active_dof = sys.model.boundary.active_dof;
0013 prescribed_dof = sys.parameter.model.boundary.prescribed_dof;
0014 
0015 <span class="comment">%%% parameters of the system</span>
0016 number_nodes = sys.parameter.model.mesh.number_nodes;
0017 number_elements = sys.parameters.model.mesh.number_elements;
0018 n_var = sys.nz/2; <span class="comment">% location of first variable u</span>
0019 
0020 E = sys.parameters.model.prop.young_mod;
0021 A = sys.parameters.model.prop.area;
0022 I = sys.parameters.model.prop.I;
0023 G = sys.parameters.model.prop.shear_mod;
0024 k = sys.parameters.model.prop.coeff_shear_k; <span class="comment">% shear coefficient</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% L_element = sys.parameters.element_geometry.L_element;</span>
0027 <span class="comment">% theta_element = sys.parameters.element_geometry.theta_element;</span>
0028 
0029 <span class="comment">%% Variables :</span>
0030 u      = zf(1:n_var,:);           du     = dzf(1:n_var,:);             <span class="comment">% Main variable: u = position</span>
0031 v      = zf(n_var + 1:2*n_var,:); dv     = dzf(n_var + 1:2*n_var,:);   <span class="comment">% Main variable: v = velocity</span>
0032 aux    = zf(2*n_var + 1:end-1,:); daux   = dzf(2*n_var + 1:<span class="keyword">end</span>,:);     <span class="comment">% Auxiliary variables</span>
0033 lambda = zf(<span class="keyword">end</span>,:);                                                  <span class="comment">% Continuation parameter</span>
0034 
0035 <span class="comment">% decomposition of aux:</span>
0036 up     = aux(              1:  number_elements,:);
0037 wp     = aux(  number_elements + 1: 2*number_elements,:);
0038 thetap = aux( 2*number_elements + 1: 3*number_elements,:);
0039 theta  = aux( 3*number_elements + 1: 4*number_elements,:);  dtheta = daux(3*number_elements + 1:4*number_elements,:);
0040 c      = aux( 4*number_elements + 1: 5*number_elements,:);      dc = daux(4*number_elements + 1:5*number_elements,:);
0041 s      = aux( 5*number_elements + 1: 6*number_elements,:);      ds = daux(5*number_elements + 1:6*number_elements,:);
0042 eps    = aux( 6*number_elements + 1: 7*number_elements,:);
0043 gam    = aux( 7*number_elements + 1: 8*number_elements,:);
0044 Fx     = aux( 8*number_elements + 1: 9*number_elements,:);
0045 Fy     = aux( 9*number_elements + 1:10*number_elements,:);
0046 M      = aux(10*number_elements + 1:11*number_elements,:);
0047 T2     = aux(11*number_elements + 1:12*number_elements,:);
0048 
0049 <span class="comment">% constructing q from Main variable u:</span>
0050 q_global = zeros(3*number_nodes,sizing);
0051 q_global(prescribed_dof,:) = 0; <span class="comment">%%%% generalize (see Cochelin line 59)</span>
0052 q_global(active_dof,:) = u;
0053 
0054 f_int_global = zeros(3*number_nodes,sizing);
0055 M_global =  sys.parameters.M_glob;
0056 
0057 <span class="keyword">for</span> i = 1:number_elements
0058     nodeA = sys.parameters.mesh.connect(i,2);
0059     nodeB = sys.parameters.mesh.connect(i,3);
0060     
0061     index_global_A = 3*(nodeA - 1) + (1:3);
0062     index_global_B = 3*(nodeB - 1) + (1:3);
0063     
0064     index = [index_global_A index_global_B]';
0065     
0066     [L_element(i), theta_element(i)] = elementOrientation(sys.parameters.mesh,i);
0067     rot_matrix = transformationMatrix(theta_element(i));
0068     q_element = rot_matrix'*q_global(index,:); <span class="comment">% rotating q_element into local frame</span>
0069     
0070     f_int_elem = [-Fx(i,:); -Fy(i,:); -M(i,:) + T2(i,:)*L_element(i)/2; Fx(i,:); Fy(i,:); M(i,:) + T2(i,:)*L_element(i)/2];
0071     f_int_global(index,:) = f_int_global(index,:) + rot_matrix*f_int_elem;
0072 
0073     Ra(i,:)                 = up(i,:)     - ((q_element(4,:) - q_element(1,:))/L_element(i));   
0074     Ra(i +   number_elements,:) = wp(i,:)     - ((q_element(5,:) - q_element(2,:))/L_element(i));
0075     Ra(i + 2*number_elements,:) = thetap(i,:) - ((q_element(6,:) - q_element(3,:))/L_element(i));
0076     Ra(i + 3*number_elements,:) = theta(i,:)  - ((q_element(6,:) + q_element(3,:))/2);    
0077     
0078 <span class="keyword">end</span>
0079 N = E*A*eps;
0080 T = k*G*A*gam;
0081 
0082 <span class="comment">% Remaining auxiliary variable residuals</span>
0083 Ra( 4*number_elements + 1: 5*number_elements,:)  = c - cos(theta);                 dRa(4*number_elements + 1: 5*number_elements,:) = dc + s.*dtheta;
0084 Ra( 5*number_elements + 1: 6*number_elements,:)  = s - sin(theta);                 dRa(5*number_elements + 1: 6*number_elements,:) = ds - c.*dtheta;
0085 Ra( 6*number_elements + 1: 7*number_elements,:)  = eps - (1 + up).*c - wp.*s + 1;
0086 Ra( 7*number_elements + 1: 8*number_elements,:)  = gam - wp.*c + (1 + up).*s;
0087 Ra( 8*number_elements + 1: 9*number_elements,:)  = Fx - N.*c + T.*s;
0088 Ra( 9*number_elements + 1: 10*number_elements,:) = Fy - N.*s - T.*c;
0089 Ra(10*number_elements + 1: 11*number_elements,:) = M - E*I*thetap;
0090 Ra(11*number_elements + 1: 12*number_elements,:) = T2 - N.*gam + (1 + eps).*T;
0091 
0092 <span class="comment">% C_global = 2*epsilon*24.67*M_global;</span>
0093 <span class="comment">%C_global = epsilon*M_global;</span>
0094 
0095 v_global = zeros(3*number_nodes,sizing); <span class="comment">% needed to calculate the residual</span>
0096 v_global(active_dof,:) = v;
0097 
0098 dv_global = zeros(3*number_nodes,sizing); <span class="comment">% needed to calculate the residual</span>
0099 dv_global(active_dof,:) = dv;
0100 
0101 Residual = -f_int_global - M_global*dv_global - lambda.*v_global;
0102 <span class="comment">%% Residues</span>
0103 <span class="comment">% Equations of the main system</span>
0104 R(1:n_var,:) = v - du;
0105 R(n_var + 1:2*n_var,:) = Residual(active_dof,:);
0106 
0107 <span class="comment">% Concatenation of the two residues</span>
0108 Rf = [ R ; Ra ];
0109 
0110 <span class="comment">%% Forcing terms</span>
0111 <span class="comment">% Should be written as if the forcing angular frequency value is 1</span>
0112 <span class="comment">% i.e. the forcing period is 2*pi</span>
0113 Forcing = zeros(2*sys.H+1,sys.nz_tot); <span class="comment">% DO NOT CHANGE this line.</span>
0114 <span class="comment">% if the equation number k is forced, write the forcing in Forced(:,k) as :</span>
0115 <span class="comment">% Forcing(:,k) = forcing_function(t);</span>
0116 <span class="comment">% Forcing(:,2*n_var - 1) = 1*cos(t);</span>
0117 <span class="comment">% Forcing(:,n_var + 4) = 50*cos(t);</span>
0118 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Mon 17-Oct-2022 20:14:50 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>